import Challange1 from "../assets/Challange1.png";
import Challange2 from "../assets/Challange2.png";
import Challange3 from "../assets/Challange3.png";
import Challange4 from "../assets/Challange4.png";
import Challange7 from "../assets/Challange7.png";
import Challange8 from "../assets/Challange8.png";
import Challange9 from "../assets/Challange9.png";
import Challange11 from "../assets/Challange11.png";
import Challange13 from "../assets/Challange13.png";
import Challange14 from "../assets/Challange14.png";
import Challange15 from "../assets/Challange15.png";
import Challange16 from "../assets/Challange16.png";
import Challange17 from "../assets/Challange17.png";
import Challange18 from "../assets/Challange18.png";
import Challange19 from "../assets/Challange19.png";
import Challange20 from "../assets/Challange20.png";
import Challange21 from "../assets/Challange21.png";
import Challange22 from "../assets/Challange22.png";
import Challange23 from "../assets/Challange23.png";
import Challange24 from "../assets/Challange24.png";
import Challange25 from "../assets/Challange25.png";
import Challange26 from "../assets/Challange26.png";
import Challange27 from "../assets/Challange27.png";
import Challange28 from "../assets/Challange28.png";
import Challange29 from "../assets/Challange29.png";
import Challange30 from "../assets/Challange30.png";
import Challange31 from "../assets/Challange31.png";
import Challange32 from "../assets/Challange32.png";
import Challange33 from "../assets/Challange33.png";
import Challange34 from "../assets/Challange34.png";
import Challange35 from "../assets/Challange35.png";
import Challange36 from "../assets/Challange36.png";
import Challange37 from "../assets/Challange37.png";
import Challange38 from "../assets/Challange38.png";
import Challange39 from "../assets/Challange39.png";
import Challange40 from "../assets/Challange40.png";
import Challange41 from "../assets/Challange41.png";
import Challange42 from "../assets/Challange42.png";
import Challange43 from "../assets/Challange43.png";
import Challange44 from "../assets/Challange44.png";
import Challange45 from "../assets/Challange45.png";
import Challange46 from "../assets/Challange46.png";
import Challange47 from "../assets/Challange47.png";
import Challange48 from "../assets/Challange48.png";
import Challange49 from "../assets/Challange49.png";
import Challange50 from "../assets/Challange50.png";
import Challange51 from "../assets/Challange51.png";
import Challange52 from "../assets/Challange52.png";
import Challange53 from "../assets/Challange53.png";
import Challange54 from "../assets/Challange54.png";
import Challange55 from "../assets/Challange55.png";
import Challange56 from "../assets/Challange56.png";
import Challange57 from "../assets/Challange57.png";
import Challange58 from "../assets/Challange58.png";
import Challange59 from "../assets/Challange59.png";
import Challange60 from "../assets/Challange60.png";
import Challange61 from "../assets/Challange61.png";
import Challange62 from "../assets/Challange62.png";
import Challange63 from "../assets/Challange63.png";
import Challange64 from "../assets/Challange64.png";
import Challange65 from "../assets/Challange65.png";
import Challange66 from "../assets/Challange66.png";
import Challange67 from "../assets/Challange67.png";
import Challange68 from "../assets/Challange68.png";
import Challange69 from "../assets/Challange69.png";
import Challange70 from "../assets/Challange70.png";
import Challange71 from "../assets/Challange71.png";
import Challange72 from "../assets/Challange72.png";
import Challange73 from "../assets/Challange73.png";
import Challange74 from "../assets/Challange74.png";
import Challange75 from "../assets/Challange75.png";
import Challange76 from "../assets/Challange76.png";
import Challange77 from "../assets/Challange77.png";
import Challange78 from "../assets/Challange78.png";
import Challange79 from "../assets/Challange79.png";
import Challange80 from "../assets/Challange80.png";
const Snippents = [
  {
    id: 1,
    name: "Dynamic Card Component.",
    heading: "Dynamic Card Component",
    description:
      "We have a Badge component with variables for name, handle and img that are unassigned. Your job is to assign those variables in the JSX so that the component renders correctly.",
    problem: [
      "Give the image a proper alt tag using the author's name",
      "Make sure the badge displays the profile image correctly",
      "Display the author's name in the badge's heading",
      "Display the author's handle below the heading",
    ],
    learningHeading: "Dynamic Card Component",
    note: [
      "The structure of dynamic components should always be predictable.",
      "Manage all the values at the top level.",
      "Learned how to use dynamic values in react.",
    ],
    image: Challange1,
  },
  {
    id: 2,
    name: "Dynamic Date",
    heading: "Dynamic Date",
    description: "Using JavaScript, replace the static date with today's date",
    problem: ["Use the getTodaysDate function to render today's date"],
    learningHeading: "Dynamic Date",
    note: [
      "Learned to get date using javascript",
      "Learned to use functions in tags.",
    ],
    image: Challange2,
  },
  {
    id: 3,
    name: "Ternary Rendering",
    heading: "Ternary Rendering",
    description:
      "Using an if statement, update the code to conditionally render the correct component based on the value of isLactoseTolerant.",
    problem: [
      "If the user is lactose intolerant, render the LactoseIntolerant component",
      "If the user is lactose tolerant, render the LactoseTolerant component",
    ],
    learningHeading: "Ternary Rendering",
    note: [
      "Conditionally render views.",
      "If value of isLactoseTolerant is true or false the view changes ",
    ],
    image: Challange3,
  },
  {
    id: 4,
    name: "Rendering Lists",
    heading: "Rendering Lists",
    description:
      "Given an array of friends, update our ul to include a li for every friend. The list item should display all the friend's names.",
    problem: [
      "Render an unordered list with all of the friends",
      "Each list item should display the correct name",
      "Each list item should be given a unique key",
    ],
    learningHeading: "Rendering Lists",
    note: [
      "Learned using map in react to render lists or Ui's.",
      "Dynamically render views.",
    ],
    image: Challange4,
  },
  {
    id: 5,
    name: "String Props",
    heading: "String Props",
    description:
      "Currently, our Badge component is displaying hardcoded values. Instead of rendering the static values, we want to pass them in as props. In this challenge, your goal is to apply the props being passed to the Badge component (name, handle, and img) so that it renders correctly.",
    problem: [
      "Give the image a proper alt tag using the author's name",
      "Make sure the badge displays the profile image correctly",
      "Display the author's name in the badge's heading",
      "Display the author's handle below the heading",
    ],
    learningHeading: "String Props",
    note: [
      "Learned passing down props to a Component.",
      "Destructuring props and using it in component.",
      "Creating reusable Component.",
    ],
    image: Challange1,
  },
  {
    id: 6,
    name: "Object props",
    heading: "Object props",
    description:
      "Although this challenge looks similar to the previous one, there are some subtle differences. As before, apply the new props to the Badge component so that it renders properly.",
    problem: [
      "Give the image a proper alt tag using the author's name",
      "Make sure the badge displays the profile image correctly",
      "Display the author's name in the badge's heading",
      "Display the author's handle below the heading",
      "Apply the correct styles to the outer div",
    ],
    learningHeading: "Object props",
    note: [
      "Learned passing down props as objects to a Component.",
      "Destructuring props and using it in component.",
      "Creating reusable Component.",
    ],
    image: Challange1,
  },
  {
    id: 7,
    name: "Function Props",
    heading: "Function Props",
    description:
      "Often times, we want to split our UI into smaller, more focused components to make our code easier to read and test. In this challenge, take the props being passed to the Badge component and use them in order to render the proper UI.",
    problem: [
      "Give the image a proper alt tag using the author's name",
      "Make sure the badge displays the profile image correctly",
      "Display the author's name in the badge's heading",
      "Display the author's handle below the heading",
      "Pass the click handler to the button so that it opens an alert when clicked",
    ],
    learningHeading: "Function Props",
    note: [
      "learned to divide components into smaller reusable components which can come handy.",
      "Creating more focused components making code more readable",
    ],
    image: Challange7,
  },
  {
    id: 8,
    name: "Children Props",
    heading: "Children Props",
    description:
      "Finish the Badge component so that it utilizes all the props passed to it.",
    problem: [
      "Give the image a proper alt tag using the author's name",
      "Make sure the badge displays the profile image correctly",
      "Display the author's name in the badge's heading",
      "Display the author's handle below the heading",
      "Display the bio text under the headings",
      "Pass the click handler to the button so that it opens an alert when clicked",
    ],
    learningHeading: "Children Props",
    note: [
      "Learned passing down Children as props.",
      "The children prop is a special prop in React that allows you to pass components or elements as children to a component.",
      "It's particularly useful for creating wrapper components like layout components or higher-order components (HOCs)",
    ],
    image: Challange8,
  },
  {
    id: 9,
    name: "Character Limit",
    heading: "Character Limit",
    description:
      "Whenever we're dealing with events in React, we can extract the logic for those events into their own event handlers.The goal with this challenge is to make it so when the user types more than 10 characters into the input field, they'll get an alert that says 'Character limit exceeded'.",
    problem: [
      "Don't show an alert if the input is under the character limit.",
      "Show an alert if the input exceeds the character limit.",
    ],
    learningHeading: "Character Limit",
    note: ["Learned Event Handling in React.", "Set an alert for char limit."],
    image: Challange9,
  },
  {
    id: 10,
    name: "Character Limit - Props",
    heading: "Character Limit - Props",
    description:
      "You'll notice that this challenge looks similar to the last one. However, instead of hard coding the character limit as we did before, we now want to make our component a little more flexible and pass it in via a prop. Fix up the code so it works as before, but with the new characterLimit prop.",
    problem: [
      "Don't show an alert if the input length is within character limit",
      "Show an alert if the input length exceeds the character limit",
    ],
    learningHeading: "Character Limit - Props",
    note: [
      "Made the Component more flexible and reusable.",
      "Divide into components and handled Dynamic char limit",
    ],
    image: Challange9,
  },
  {
    id: 11,
    name: "Light Switch",
    heading: "Light Switch",
    description:
      "In order to persist a value across renders and update the UI when that value changes, we need to use React's useState hook. In this challenge, you'll need to create a button that toggles the mode state between light and dark.",
    problem: [
      "The app renders without crashing",
      "mode defaults to dark",
      "mode toggles between dark and light when the button is clicked",
    ],
    learningHeading: "Light Switch",
    note: [
      "Learned to use useState hook",
      "Learned Dynamic Styling components.",
      "If predefined all the styles in dark and light mode we can easily toggle with One Click",
    ],
    image: Challange11,
  },
  {
    id: 12,
    name: "Light Switch - Concise",
    heading: "Light Switch - Concise",
    description:
      "You may have noticed that in our last 'Light Switch' example, we had some wasted keystrokes. Specifically, depending on how you set it up, you may have written two methods (handleDarkMode and handleLightMode) for updating our mode state like in our current starting code. Also, we rendered two buttons, one for each event handler.In this challenge, consolidate our logic into a single event handler and a single button element.",
    problem: [
      "The app renders without crashing",
      "mode defaults to dark",
      "mode toggles between dark and light when the button is clicked",
    ],
    learningHeading: "Light Switch - Concise",
    note: ["Optimized dark and light mode code."],
    image: Challange11,
  },
  {
    id: 13,
    name: "Counter",
    heading: "Counter",
    description:
      "This challenge is pretty straight forward. Increment or decrement count whenever the user clicks on the corresponding button.",
    problem: [
      "Render the initial state correctly",
      "Increment count when the user clicks the '+' button",
      "Decrement count when the user clicks the '-' button",
      "Render the correct count after multiple button clicks",
    ],
    learningHeading: "Counter",
    note: ["Created a counter", "Dynamic Rendering", "Event Handling"],
    image: Challange13,
  },
  {
    id: 14,
    name: "Smart Character Limit",
    heading: "Smart Character Limit",
    description:
      "Now that you know how to add preserve state in React, let's revisit our Character Limit challenge from earlier in the course and make it a little more sophisticated.The goal of this app is to get some input from the user, but only 'submit' that input if its length is less than or equal to characterLimit (20 characters, by default). Unlike our other 'Character Limit' challenges, this one shows the user how many characters they have left before they hit the limit.",
    problem: [
      "LimitedTextInput renders an input and submit button",
      "Update the remaining characters count when the user types",
      "Add an error class to the 'Characters remaining:' span element when the user exceeds the character limit and a no-error when they haven't",
      "alert 'The input exceeds the character limit. Please shorten your text.' when the user submits a form with too many characters",
      "alert 'Thanks for your submission' when the user submits a form with an acceptable number of characters",
      "Reset the input back to an empty string when the form is successfully submitted",
    ],
    learningHeading: "Smart Character Limit",
    note: [
      "Calculated and Displayed Characters remaining Dynamically.",
      "Handled Validation on submit",
      "Reset the string after successful submission.",
    ],
    image: Challange14,
  },
  {
    id: 15,
    name: "Password Toggle",
    heading: "Password Toggle",
    description:
      "In this challenge, you're going to implement the logic for an input field that accepts a password. However, instead of a boring input field, this one is like... slightly less boring.What makes it less boring is it gives the user the option to toggle the visibility of the password by giving them a button with some cute emojis, 🙊 or 🙈 depending on if the password is visible.All the JSX is in place, all you need to do is properly handle the different states of the component and update handleChange and handleToggleVisibility so that the component behaves as expected.",
    problem: [
      "Update the password length count when the input changes",
      "Update the text style based on the password length threshold",
      "Allow users to toggle the password visibility",
      "Show an alert with a success message when the password length is equal to or above the threshold on form submission",
      "Show an alert with an error message when the password length is below the threshold on form submission",
    ],
    learningHeading: "Password Toggle",
    note: [
      "Learned to dynamically toggle visibility.",
      "Handled dynamic length count.",
      "Handled submit validation.",
      "Toggled Icons",
    ],
    image: Challange15,
  },
  {
    id: 16,
    name: "Multistep Form",
    heading: "Multistep Form",
    description:
      "In this challenge you're given a multistep form for getting data from the user. With the JSX already in place, update the component's state and functions in order to allow the user to progress through the form, updating the state as necessary.",
    problem: [
      "Allow the user to transition to the next step",
      "Allow the user to return to the previous step",
      "Update the formData as the user progresses through the form",
      "When finished, submit the form and reset the component's state",
    ],
    learningHeading: "Multistep Form",
    note: [
      "Efficiently handled multiple form Inputs.",
      "Managed and rendered expected multiform view.",
      "Wrote Reusable and Modular Code.",
    ],
    image: Challange16,
  },
  {
    id: 17,
    name: "Form Builder",
    heading: "Form Builders",
    description:
      "In this challenge we're going to get meta and build a form builder. It looks complex, but with the JSX already in place, your primary job is to manage the formFields array. The user will need to be able to add items to it, update items in it, and remove items from it.All of the functions with their parameters are in place, you'll just need to examine the JSX and update each accordingly.",
    problem: [
      "Allow users to add a form field",
      "Allow users to delete form fields",
      "Allow users to update form field values",
      "Allow users to submit the dynamic form with the new values",
    ],
    learningHeading: "Form Builder",
    note: [
      "Created a dynamic Form builder component.",
      "Handled dynamic properties for fields in a very Efficient and Clean way.",
      "Finally displayed output from Form fields.",
    ],
    image: Challange17,
  },
  {
    id: 18,
    name: "Search Filter",
    heading: "Search Filter",
    description:
      "In this challenge, you're given an app that uses useEffect as a way to react to changes in the search term. That's not ideal – useEffect should be used for synchronizing, not for reacting to changes in a value. Refactor the app to get rid of useEffect but keep the same functionality.",
    problem: [
      "Render the list of items",
      "Filter the list of items based on search term",
      "Don't use useEffect",
    ],
    learningHeading: "Search Filter",
    note: [
      "Implemented Search functionality to list.",
      "Render list Correctly and without useEffect hook.",
      "Learned that useEffect should be used for synchronizing",
    ],
    image: Challange18,
  },
  {
    id: 19,
    name: "Clock",
    heading: "Clock",
    description:
      "In this challenge, you'll be synchronizing the current time with your component's state by updating the UI every second with the new time. To do that, you'll need the right combination of useEffect, component state, and the browser's setInterval method.",
    problem: ["Update the time every second", "Clear the timer when unmounted"],
    learningHeading: "Clock",
    note: [
      "Displayed time in real time.",
      "Learned about mounting, updating, and unmounting phases in react.",
      "Cleared time interval and saved from memory leak",
    ],
    image: Challange19,
  },
  {
    id: 20,
    name: "Country Info",
    heading: "Country Info",
    description:
      "In this challenge, you'll be synchronizing the result of fetching country data from an external API with your component's state.",
    problem: [
      "Display a loading state when fetching data",
      "Fetch new data based on the user's input",
      "Render an error message if fetch fails",
    ],
    learningHeading: "Country Info",
    note: [
      "Learned to use useEffect and synchronizing the result.",
      "Handled Loading state and error Also avoided multiple api been called back to back",
      "Dynamically displayed data from the api.",
    ],
    image: Challange20,
  },
  {
    id: 21,
    name: "Hacker News",
    heading: "Hacker News",
    description:
      "In this challenge, we'll be fetching data from the Hacker News API. However, unlike the other effects challenges, the state and event handlers for this one don't need updating. Instead, given the fetchData function, you'll need to synchronize your component with the Hacker News API and then update the JSX appropriately.This one is tricky so take your time and think it through. Anywhere in the JSX you see null or TODO you'll need to update it.",
    problem: [
      "Fetch data based on the search query",
      "Display the loading state while fetching",
      "Fetch new results when the tag filter changes",
      "Allow the user to navigate to the next and previous pages",
      "Disable the Next and Previous buttons based on the number of pages",
      "Display the results in a numbered list, with each page showing the correct position of each post",
    ],
    learningHeading: "Hacker News",
    note: [
      "Fetched data based on the search query",
      "Displayed the loading state while fetching.",
      "Fetched new results when the tag filter changes.",
      "Allowed the user to navigate to the next and previous pages",
      "Disabled the Next and Previous buttons based on the number of pages",
      "Displayed the results in a numbered list, with each page showing the correct position of each post.",
    ],
    image: Challange21,
  },
  {
    id: 22,
    name: "Autofocus",
    heading: "Autofocus",
    description:
      "In this challenge you're given a ref and a simple input element. Your job is to autofocus the input when the component first renders.",
    problem: ["Autofocus the input when the component renders"],
    learningHeading: "Autofocus",
    note: [
      "Learned to use useRef an escape hatch to use vanilla js without messing with react-dom",
      "Used useRef to focus current element",
    ],
    image: Challange22,
  },
  {
    id: 23,
    name: "Video Player",
    heading: "Video Player",
    description:
      "In this challenge, you'll give the user the ability to play and pause the video. To do so, you'll need to invoke the play or pause methods on the video element itself. You'll also want to update the UI to reflect the current state of the video.",
    problem: [
      "Toggle the play state when the button is clicked",
      "Play and pause the video when the button is clicked",
    ],
    learningHeading: "Video Player",
    note: [
      "Played and paused the video with useRef hook.",
      "Updated the UI to reflect the current state of the video",
    ],
    image: Challange23,
  },
  {
    id: 24,
    name: "Field Notes",
    heading: "Field Notes",
    description:
      "In this challenge you're tasked with completing an app that collects new notes from the user and displays them in a list. Whenever a new note is added, you'll need to scroll it into view.",
    problem: [
      "Add a new note when the user submits the form",
      "Scroll the new note into view",
      "Clear the input field when the user submits a valid note",
      "Prevent empty notes from being added",
    ],
    learningHeading: "Field Notes",
    note: [
      "Scrolled the new note into view using useRef and vanilla js.",
      "Clear the input field when the user submits a valid note.",
      "Prevented empty notes from being added.",
    ],
    image: Challange24,
  },
  {
    id: 25,
    name: "Click Outside",
    heading: "Click Outside",
    description:
      "In this challenge you'll be adding a modal experience to the app. The user needs to be able to open the modal and then close it either by clicking the close icon in the modal itself, or by clicking anywhere outside of the modal.You'll need both component state and a reference to the modal to make it work properly. You'll also want to reference the pointerdown event if you're not familiar with it.",
    problem: [
      "Don't render the modal by default",
      "Clicking the 'Open Modal' button should open the modal",
      "Don't close the modal when the dialog is clicked",
      "Close modal by clicking close icon",
      "Close the modal when the user clicks outside of the modal",
    ],
    learningHeading: "Click Outside",
    note: [
      "Created toggle modal.",
      "Calculated element and used pointerdown event to handle area that shouldn't close modal.",
      "Handled close modal in vanilla js.",
    ],
    image: Challange25,
  },
  {
    id: 26,
    name: "Expanding Textarea",
    heading: "Expanding Textarea",
    description:
      "In this challenge you'll need to add functionality to the app so that the user can type into the textarea and it will expand to fit the content as they type.",
    problem: [
      "Update the value for the textarea when typing",
      "Set the textarea's height based on its scroll height",
    ],
    learningHeading: "Function Props",
    note: [
      "Calculated textarea's height based on its scroll height.",
      "Updated the value for the textarea when typing.",
    ],
    image: Challange26,
  },
  {
    id: 27,
    name: "Follow the Leader",
    heading: "Follow the Leader",
    description:
      "The concept is simple, animate the center of the box to the coordinates that the user clicks.To do this, you'll need to update the position array to include the new x and y positions of where the box should transform to.",
    problem: ["Animate the box to the coordinates that the user clicks"],
    learningHeading: "Follow the Leader",
    note: [
      "Calculated x and y positions.",
      "And animated the box to move where you click.",
    ],
    image: Challange27,
  },
  {
    id: 28,
    name: "Auth",
    heading: "Auth",
    description:
      "In this challenge our goal is to make the user's authentication state (as well as a way to update that state) available to anywhere in our component tree that needs it.You're given an authContext with the expected shape of the user's auth state - isAuthenticated: boolean, login: function, logout: function.Your challenge is to finish the AuthProvider component - making isAuthenticated, login, and logout available anywhere in the component tree - and then to use those values in any component that needs them.",
    problem: [
      "Render a login form when the user is not authenticated",
      "Display the Dashboard component after the user logs in",
      "Display the login screen if the user logs out",
    ],
    learningHeading: "Auth",
    note: [
      "Used useContext hook for the login data to be available anywhere in the component tree.",
      "Rendered a login form when the user is not authenticated.",
      "Displayed the Dashboard component after the user logs in.",
      "Creating reusable Component.",
    ],
    image: Challange28,
  },
  {
    id: 29,
    name: "Translations",
    heading: "Translations",
    description:
      "In this challenge your goal is to make translation state (as well as a way to update that state) available anywhere in the component tree.You're given a languageContext with the expected shape of the translation data - language: string, changeLanguage: function, and translation: function.Your challenge is to finish the LanguageProvider component - making language, changeLanguage, and translation available anywhere in the component tree - and then to use those values in any component that needs them.",
    problem: [
      "Update the language based on the user's selection",
      "Apply the correct translation when the language is changed",
    ],
    learningHeading: "Translations",
    note: ["Updated the language based on the user's selection."],
    image: Challange29,
  },
  {
    id: 30,
    name: "Tabs",
    heading: "Tabs",
    description:
      "Given the completed JSX, finish the app so that the correct tab content is shown when a tab is clicked.This challenge is deliberately vague. You'll need to carefully examine the final app as well as each component and what props it receives to figure out how to complete the challenge.Once finished, you should have a working tabs implementation that is hyper flexible and not coupled at all to the current layout of the app.",
    problem: ["Show the correct tab content when a tab is clicked"],
    learningHeading: "Tabs",
    note: [
      "Created a simple reusable Tabs component.",
      "Used context to manage the active tab.",
    ],
    image: Challange30,
  },
  {
    id: 31,
    name: "News Feed",
    heading: "News Feed",
    description:
      "In this challenge you're given a news feed with different videos. To improve the UX of your feed, the challenge is to make sure only one video can play at a time.Specifically you'll probably want to tackle the following steps.Finish the NewsFeed component by rendering a VideoItem component for every video in the videos array.Finish the VideoPlaybackProvider component so that playingVideoId and setPlayingVideoId are available throughout the component tree.Finish VideoItem so that the user can play and pause a video, but that when they do, any other video that is currently playing is paused.In my opinion this is the hardest challenge we've had throughout the course so far, so keep that in mind as you wrestle with imposter syndrome and self-doubt 🫶.",
    problem: ["Allow only one video to play at a time"],
    learningHeading: "News Feed",
    note: [
      "Created a new feed application flow.",
      "used Context and managed to pause other videos when clicked to play on new video.",
    ],
    image: Challange31,
  },
  {
    id: 32,
    name: "Multistep Form with useReducer",
    heading: "Multistep Form with useReducer",
    description:
      "Given the solution code to the previous 'Multistep Form' challenge you encountered earlier in the course, your job is to refactor the app to use useReducer to manage state instead of useState.",
    problem: [
      "Enable a user to transition to the next step",
      "Enable a user to return to the previous Step",
      "Keep track of the step and form state correctly",
      "Reset the form when the user submits it",
      "Use the useReducer hook to manage the component's state",
    ],
    learningHeading: "Multistep Form with useReducer",
    note: [
      "Used the useReducer hook to manage the component's state.",
      "Reset the form when the user submits it",
    ],
    image: Challange32,
  },
  {
    id: 33,
    name: "Task Manager",
    heading: "Task Manager",
    description:
      "Given the completed TaskManager component, your challenge is to finish implementing the reducer function so that the user can add, update, and delete tasks.",
    problem: [
      "The user should be able to add a new task",
      "The user should be able to update the status of a task",
      "The user should be able to delete a task",
    ],
    learningHeading: "Task Manager",
    note: [
      "With Reducer hooks created a simple task manager.",
      "User can create add, delete and update the task status.",
    ],
    image: Challange33,
  },
  {
    id: 34,
    name: "Add To Cart",
    heading: "Add To Cart",
    description:
      "Given the final ShoppingCart component (including all the JSX and event handlers), your job is to finish implementing both the reducer function as well as the calculateTotal function.calculateTotal takes in the cart and should return a single numeric value representing the total cost of all the items in the cart.For the reducer, look at the component to figure out which action types are being dispatched as well as the shape of the action objects.",
    problem: [
      "Render the appropriate UI if there are no items in the cart",
      "Give the user the ability to add items to the shopping cart",
      "Give the user the ability to remove items from the shopping cart",
      "Appropriately update the quantity of items in the shopping cart",
      "Appropriately calculate the total cost of all items in the shopping cart",
    ],
    learningHeading: "Add To Cart",
    note: [
      "Render the appropriate UI if there are no items in the cart.",
      "Developed Cart logic.",
      "Add and remove functionality and calculated Total",
      "Rendered the UI conditionally.",
    ],
    image: Challange34,
  },
  {
    id: 35,
    name: "Undo Redo",
    heading: "Undo Redo",
    description:
      "The goal of this challenge is, using useReducer, add increment, decrement, undo, and redo functionality to your application. Unlike the other challenges, you'll need to wire up useReducer, the event handlers, and the reducer function yourself - you won't need to touch the JSX though.",
    problem: [
      "Clicking increment should increment the counter",
      "Clicking decrement should decrement the counter",
      "Clicking undo and redo should undo or redo the previous action",
    ],
    learningHeading: "Undo Redo",
    note: [
      "handled increment should increment the counter.",
      "Handled undo and redo should undo or redo the previous action.",
    ],
    image: Challange35,
  },
  {
    id: 36,
    name: "Localized Primes",
    heading: "Localized Primes",
    description:
      "Complete the app so that the user can change their locale as well as iterate through every prime number. Take special care to only re-calculate the prime number when the user clicks NEXT PRIME.",
    problem: [
      "Increment the prime number count when the button is clicked",
      "Change the language when the select option is changed",
      "Memoize nthprime so that it's only re-calculated when count changes",
    ],
    learningHeading: "Localized Primes",
    note: [
      "Created a prime number calculator and added language filter.",
      "user can change their locale as well as iterate through every prime number.",
      "Saved the re-calculation of prime number when the user clicks NEXT PRIME with useMemo hook.",
    ],
    image: Challange36,
  },
  {
    id: 37,
    name: "Data Table",
    heading: "Data Table",
    description:
      "Given an application that already has the completed JSX and event handlers for deciding how you should filter and sort the data (searchTerm, sortColumn, and sortOrder), your job is to fetch the data (using the fetchData function), and then, in the most performant way possible, using searchTerm, sortColumn, and sortOrder, update the filteredData and sortedData variables.filteredData should be a memoized array of data that has been filtered based on the searchTerm.sortedData should be a memoized array of filteredData that has been sorted based on the sortColumn and sortOrder.",
    problem: [
      "The user can search Pokémon",
      "The user can sort Pokémon",
      "The Pokémon data is correctly memoized",
    ],
    learningHeading: "Data Table",
    note: [
      "Created a Data table filter and sort.",
      "Added toggle row functionality.",
      "Added search filter to all columns",
      "Used memoization for data to filter and sort data based on sort column and order",
    ],
    image: Challange37,
  },
  {
    id: 38,
    name: "Optimizing Renders",
    heading: "Optimizing Renders",
    description:
      "In this challenge you're given two components, ParentComponent and ChildComponent. The goal is to make it so whenever the button in ChildComponent is clicked, you increment count in the ParentComponent. The caveat is that ChildComponent should only ever render once, when the app first loads.",
    problem: [
      "Increment count when the button is clicked",
      "ChildComponent should only render once, when the app first loads",
    ],
    learningHeading: "Optimizing Renders",
    note: [
      "Incremented count when the button is clicked.",
      "Render Child component only once when app first loads used memo hook, useCallback, useState, useEffect .",
    ],
    image: Challange38,
  },
  {
    id: 39,
    name: "React Ruler",
    heading: "React Ruler",
    description:
      "Using the ResizeObserver API, synchronize the width of the ruler (the article element) with your component's width state.",
    problem: [
      "Update the width state when the ruler is resized",
      "Clean up the ResizeObserver when the component is removed from the DOM",
    ],
    learningHeading: "Function Props",
    note: [
      "Created a resizable ruler.",
      "Used useLayoutEffect hook to calculate width before the view is loaded.",
    ],
    image: Challange39,
  },
  {
    id: 40,
    name: "Flexible Tooltip",
    heading: "Flexible Tooltip",
    description:
      "You're given an app that... kind of works. The only problem is when you hover over any of the yellow underlined text, the tooltip renders in the wrong position. Your job is to fix the app so that the tooltip renders correctly - either above the text if there's room, or below it if there's not.To do this, you'll want to utilize the browser's getBoundingClientRect API to get position information about specific elements.You won't need to touch any code other than the Tip component.",
    problem: [
      "Position the tooltip above the hovered text if there's enough room",
      "If there's not enough room above it, and if there's more room below it than above it, position the tooltip below the hovered text",
      "If there's not enough room above it, and there's less room below it, position the tooltip above the hovered text",
    ],
    learningHeading: "Flexible Tooltip",
    note: ["Created Flexible tooltip to smartly show tooltip."],
    image: Challange40,
  },
  {
    id: 41,
    name: "Match Media",
    heading: "Match Media",
    description:
      "You're given a functioning app that utilizes useEffect with some React state to synchronize the browser's dimension with the component. This works, but it's not ideal. Instead, refactor the app to utilize React's useSyncExternalStore hook.",
    problem: [
      "Refactor the app to keep the same functionality but use the useSyncExternalStore hook",
      "Show the correct UI for larger browser dimensions",
      "Show the correct UI for mobile browser dimensions",
      "Subscribe and unsubscribe to the browser's dimensions using the MatchMedia API",
    ],
    learningHeading: "Match Media",
    note: ["used useSyncExternalStore hook to Match Media."],
    image: Challange41,
  },
  {
    id: 42,
    name: "useDocumentTitle hook",
    heading: "useDocumentTitle hook",
    description:
      "useDocumentTitle allows you to dynamically update the title of a webpage. ",
    problem: [
      "Update the document's title with the first argument passed to useDocumentTitle",
      "Update the document's title when the first argument passed to useDocumentTitle changes",
    ],
    learningHeading: "useDocumentTitle hook",
    note: [
      "Learned to create a custom hook.",
      "Create a hook to change current tab's title.",
    ],
    image: Challange42,
  },
  {
    id: 43,
    name: "useDefault hook",
    heading: "useDefault hook",
    description:
      "The useDefault hook behaves similar to useState but with one difference - if the state of the hook is undefined or null, useDefault will default the state back to a provided default value.",
    problem: [
      "useDefault should return an array",
      "On the initial render, the state that useDefault returns should be the same as the initialValue given to useDefault when it was invoked",
      "When invoked, useDefault's updater function should update its state to the value passed to the updater function",
      "If useDefault's state becomes undefined, the state that useDefault returns should be the defaultValue given to useDefault when it was invoked",
      "If useDefault's state becomes null, the state that useDefault returns should be the defaultValue given to useDefault when it was invoked",
    ],
    learningHeading: "useDefault hook",
    note: [
      "Learned to create a custom hook.",
      "Create a hook to return default state when null or undefined.",
    ],
    image: Challange43,
  },
  {
    id: 44,
    name: "useToggle hook",
    heading: "useToggle hook",
    description:
      "YuseToggle has a similar API to useState in that both return an array with the first item being the state and the second item being a way to update that state. However, unlike useState, useToggle's state value can only ever be a boolean.",
    problem: [
      "useToggle should correctly establish its initial value, casting it to a boolean if it's not one",
      "useToggle should toggle the state when its updater function is invoked without a value",
      "useToggle should set the state to the provided value when its updater function is called with a boolean value",
      "useToggle should not change the state when its updater function is called with the same boolean value",
      "useToggle should toggle the state when its updater function is called with a value that isn't a boolean",
    ],
    learningHeading: "useToggle hook",
    note: [
      "Learned to create a custom hook.",
      "handled the useToggle hook state in such a way that it is always a boolean.",
    ],
    image: Challange44,
  },
  {
    id: 45,
    name: "usePrevious hook",
    heading: "usePrevious hook",
    description:
      "usePrevious is useful for tracking what a value was during the previous render. This can be particularly handy in scenarios where it's necessary to compare the current value with the previous one, such as triggering actions or rendering based on changes.",
    problem: [
      "usePrevious should return null on the first render",
      "usePrevious should return the previous value when the current value changes",
    ],
    learningHeading: "usePrevious hook",
    note: [
      "Learned to create a custom hook.",
      "handled the usePrevious hook to save previous value of color.",
    ],
    image: Challange45,
  },
  {
    id: 46,
    name: "usePreferredLanguage hook",
    heading: "usePreferredLanguage hook",
    description:
      "usePreferredLanguage returns a string that represents the preferred language of the user, as set in the browser settings. You can get access to their preferred language via navigator.language. You can listen to changes to the preferred language by adding an event listener for the languagechange event.",
    problem: [
      "usePreferredLanguage should return the user's preferred language as a string",
      "usePreferredLanguage should listen for changes to the user's preferred language and update the return value accordingly",
      "usePreferredLanguage should unsubscribe from the languagechange event when the component that uses usePreferredLanguage is removed from the DOM",
      "usePreferredLanguage should throw an error if it's used on the server",
    ],
    learningHeading: "usePreferredLanguage hook",
    note: [
      "Learned to create a custom hook.",
      "handled the usePreferredLanguage to detect the language and render accordingly.",
    ],
    image: Challange46,
  },
  {
    id: 47,
    name: "useFavicon hook",
    heading: "useFavicon hook",
    description:
      "useFavicon allows you to dynamically update the document's favicon.",
    problem: [
      "Update the document's favicon with the href passed to useFavicon",
      "Update the document's favicon when the href passed to useFavicon changes",
    ],
    learningHeading: "useFavicon hook",
    note: [
      "Learned to create a custom hook.",
      "handled the useFavicon hook to change favicon.",
    ],
    image: Challange47,
  },
  {
    id: 48,
    name: "useCopyToClipboard hook",
    heading: "useCopyToClipboard hook",
    description:
      "The useCopyToClipboard hook provides a simple way to copy text to the user's clipboard.",
    problem: [
      "useCopyToClipboard should return an array with the first item being the value that was copied and the second being a function to copy a value to the user's clipboard",
      "The first item in the array that useCopyToClipboard returns should be the value that was copied to the clipboard",
      "The second item in the array that useCopyToClipboard returns should copy a provided value to the user's clipboard",
      "useCopyToClipboard should provide a fallback for the copy functionality for browsers that don't support navigator.writeText",
    ],
    learningHeading: "useCopyToClipboard hook",
    note: [
      "Learned to create a custom hook.",
      "handled the useCopyToClipboard hook copy text to the clipboard.",
    ],
    image: Challange48,
  },
  {
    id: 49,
    name: "useInterval hook",
    heading: "useInterval hook",
    description:
      "useInterval provides a convenient way to create and manage intervals in React. Using window.setInterval under the hood, useInterval repeatedly invokes a provided callback function at a specified interval and automatically clears the interval when the component using useInterval is removed from the DOM.",
    problem: [
      "useInterval should accept a callback function and an interval integer as arguments",
      "useInterval should invoke the callback function every interval milliseconds",
      "useInterval should return a function that clears the interval",
      "useInterval should clear the interval when the component using useInterval is removed from the DOM",
    ],
    learningHeading: "useInterval hook",
    note: [
      "Learned to create a custom hook.",
      "handled the useInterval hook copy to run a function with time interval and clear it when stopped.",
    ],
    image: Challange49,
  },
  {
    id: 50,
    name: "useCounter hook",
    heading: "useCounter hook",
    description:
      "useCounter is a hook for managing a numeric counter value. It allows you to specify a min and max value, then gives you helper methods (increment, decrement, set, and reset) for managing the value.",
    problem: [
      "As its first argument, useCounter should accept a starting value and default it to 0 if no value is provided",
      "As its second argument, useCounter should also accept an object with min and max values and throw an error if the starting value is outside of that range",
      "useCounter should return an array with the first item being the current value of count and the second being an object with increment, decrement, set, and reset methods",
      "useCounter should increment the count value by 1 when increment is called (unless the max value is reached)",
      "useCounter should decrement the count value by 1 when decrement is called (unless the min value is reached)",
      "useCounter should set the count value to the provided value when set is called (unless the min or max value is reached)",
      "useCounter should reset the count value to the starting value when reset is called (unless the count value is already the starting value)",
    ],
    learningHeading: "useCounter hook",
    note: [
      "created useCounter hook to manage numeric Counter value. with some helper functions",
    ],
    image: Challange50,
  },

  {
    id: 51,
    name: "useIsClient hook",
    heading: "useIsClient hook",
    description:
      "useIsClient is useful for determining if it's safe to run certain client-only hooks like useMediaQuery or useLocalStorage. It returns a boolean determining if React's useEffect hook has finished running (which means the app is being rendered on the client).",
    problem: [
      "useIsClient should return a boolean value",
      "useIsClient should return true if the app is being rendered on the client",
      "useIsClient should return false if the app is not being rendered on the client",
    ],
    learningHeading: "useIsClient hook",
    note: [
      "created useIsClient hook to determining if it's safe to run certain client-only hooks.",
    ],
    image: Challange51,
  },

  {
    id: 52,
    name: "useQueue hook",
    heading: "useQueue hook",
    description:
      "useQueue gives you an easy way to manage a queue type data structure. If you're not familiar, a queue follows the FIFO (first in, first out) principle. This means that the first element added to the queue is the first element that should be removed.",
    problem: [
      "useQueue should accept an initialValue argument that will be used to initialize the queue.",
      "useQueue should return an object with add, remove, clear, first, last, size, and queue properties",
      "useQueue should implement an add method that adds an element to the end of the queue",
      "useQueue should implement a remove method that removes the first element from the queue and returns it",
      "useQueue should implement a clear method that sets the queue to an empty array",
      "useQueue should implement a first property that returns the first element in the queue",
      "useQueue should implement a last property that returns the last element in the queue",
      "useQueue should implement a size property that returns the size of the queue",
    ],
    learningHeading: "useQueue hook",
    note: [
      "created useQueue hook to function as Queue with some helper functions",
    ],
    image: Challange52,
  },
  {
    id: 53,
    name: "useTimeout hook",
    heading: "useTimeout hook",
    description:
      "useTimeout provides a convenient way to create and manage timeouts in React. Using window.setTimeout under the hood, useTimeout invokes a provided callback function after ms milliseconds and automatically clears the timeout when the component using useTimeout is removed from the DOM.",
    problem: [
      "useTimeout should invoke the provided callback function after ms milliseconds",
      "useTimeout should reset the timeout when the ms prop changes",
      "useTimeout should return a function that clears the timeout",
      "useTimeout should clear the timeout when the component using useTimeout is removed from the DOM",
    ],
    learningHeading: "useTimeout hook",
    note: [
      "created useTimeout hook to run a function after set time is passed",
      "This challange could be improved with useEffectEvent",
    ],
    image: Challange53,
  },
  {
    id: 54,
    name: "useWindowSize hook",
    heading: "useWindowSize hook",
    description:
      "The useWindowSize hook is useful for retrieving and tracking the dimensions (innerWidth and innerHeight) of the browser window. It attaches an event listener to the resize event, ensuring its state (width and height) are updated dynamically whenever the window is resized.",
    problem: [
      "useWindowSize should return the correct width and height values of the browser's dimension",
      "When the browser is resized, useWindowSize should return the updated width and height values of the browser's dimension",
      "useWindowSize should clean up any event listeners it established when the component using useWindowSize is removed from the DOM",
    ],
    learningHeading: "useWindowSize hook",
    note: [
      "created useWindowSize hook to accurately calculate the height and width of window.",
    ],
    image: Challange54,
  },
  {
    id: 55,
    name: "useVisibilityChange hook",
    heading: "useVisibilityChange hook",
    description:
      "useVisibilityChange is useful for tracking the visibility state (document.visibilityState) of the document. It returns a boolean value that indicates whether the document is visible or not. It also updates the value when the document's visibility state changes by adding an event listener to the document's visibilitychange event.",
    problem: [
      "useVisibilityChange should return a boolean value that defaults to true",
      "useVisibilityChange should return true when the document is visible",
      "useVisibilityChange should return false when the document is not visible",
      "useVisibilityChange should clean up the event listener when the component using useVisibilityChange is removed from the DOM",
    ],
    learningHeading: "useVisibilityChange hook",
    note: ["created useVisibilityChange hook to count click away form tab."],
    image: Challange55,
  },
  {
    id: 56,
    name: "useList hook",
    heading: "useList hook",
    description:
      "useList allows the user to more conveniently manage a list of items. It returns an array with the list as the first element and an object with methods to manage the list as the second element.",
    problem: [
      "useList should return an array with the list and an object containing methods for set, push, removeAt, insertAt, updateAt, and clear",
      "useList should accept an optional initial value for the list",
      "useList should have a set method that allows the user to set the list to a new value",
      "useList should have a push method that allows the user to push a new element onto the end of the list",
      "useList should have a removeAt method that allows the user to remove an element at a given index",
      "useList should have an insertAt method that allows the user to insert an element at a given index",
      "useList should have an updateAt method that allows the user to update an element at a given index",
      "useList should have a clear method that allows the user to clear the list",
    ],
    learningHeading: "useList hook",
    note: [
      "Created useList hook to manage a list and provide helper functions to manipulate it.",
    ],
    image: Challange56,
  },
  {
    id: 57,
    name: "useObjectState hook",
    heading: "useObjectState hook",
    description:
      "useObjectState works similar to useState in that it returns an array with the first item being the state and the second being a way to update that state. However, unlike useState, the state that useObjectState manages is an object and it will merge the new state with the old state instead of replacing it.",
    problem: [
      "useObjectState should accept an initial value and return an array with the first item being the state and the second item being a way to update that state",
      "useObjectState should accept an object and merge it with the current state",
      "useObjectState should support an updater function similar to useState",
      "useObjectState should ignore updating the state with any values that aren't plain objects",
    ],
    learningHeading: "useObjectState hook",
    note: [
      "Created useObjectState hook to manage a useState hook like object. ",
      "Unlike useState, the state that useObjectState manages is an object and it will merge the new state with the old state instead of replacing it",
    ],
    image: Challange57,
  },
  {
    id: 58,
    name: "useDebounce hook",
    heading: "useDebounce hook",
    description:
      "The useDebounce hook is useful for delaying the execution of functions or state updates until a specified time period has passed without any further changes to the debounced value. This is especially useful in scenarios such as handling user input or triggering network requests, where it effectively reduces unnecessary computations and ensures that resource-intensive operations are only performed after a pause in the input activity. This hook works by taking in two arguments, value and delay. value is the value you want to debounce, and delay is the amount of milliseconds you want to wait before updating the value.",
    problem: [
      "Return a piece of state that is initialized with the value passed to useDebounce",
      "Update the debounced value after delay milliseconds has passed since the last time value changed",
      "Do not update the debounced value before delay milliseconds has passed since the last time value changed",
      "Cleanup the previous timeout when value or delay changes",
    ],
    learningHeading: "useDebounce hook",
    note: ["created useDebounce hook to delay the search for provided sec."],
    image: Challange58,
  },
  {
    id: 59,
    name: "useContinuousRetry hook",
    heading: "useContinuousRetry hook",
    description:
      "useContinuousRetry allows you to repeatedly call a specified callback function at a defined interval until the callback returns a truthy value, indicating a successful resolution. This hook is particularly handy when dealing with asynchronous operations or API calls that may fail temporarily and need to be retried automatically.",
    problem: [
      "useContinuousRetry should accept a callback function, an interval in milliseconds, and an options object",
      "useContinuousRetry should return a boolean value indicating whether or not the callback has resolved",
      "useContinuousRetry should call the callback function at the specified interval until the callback returns a truthy value",
      "useContinuousRetry should stop calling the callback function if the number of retries exceeds the maxRetries option",
      "useContinuousRetry should clear the interval when the component is removed from the DOM",
    ],
    learningHeading: "useContinuousRetry hook",
    note: [
      "created useContinuousRetry hook to console log Continuous retry until hasResolved is true or max tries exceeds.",
    ],
    image: Challange59,
  },
  {
    id: 60,
    name: "useHistoryState hook",
    heading: "useHistoryState hook",
    description:
      "useHistoryState is similar to useState or useReducer in that it allows you to manage state in a React component. The difference is useHistoryState comes with some extra functionality that keeps track of the history of the changes made to the state.",
    problem: [
      "useHistoryState should return an object with the following properties: state, canUndo, canRedo, set, undo, redo, clear",
      "useHistoryState should set the initial state to the value passed to the hook",
      "useHistoryState should allow the user to undo the last action",
      "useHistoryState should allow the user to redo the last action",
      "useHistoryState should allow the user to set the state to a new value",
      "useHistoryState should allow the user to clear the state and reset it to its initial value",
      "useHistoryState should return the correct values for canUndo and canRedo based on the current state",
    ],
    learningHeading: "useHistoryState hook",
    note: [
      "created useHistoryState hook to maintain state and keep history with helper functions undo, redo, clear.",
    ],
    image: Challange60,
  },
  {
    id: 61,
    name: "useEventListener hook",
    heading: "useEventListener hook",
    description:
      "useEventListener gives you a simple way to add event listeners to a target element.",
    problem: [
      "useEventListener should accept a target element, an eventName, a handler function, and an optional options object",
      "useEventListener should add an event listener to the target element unless the target element is not defined",
      "useEventListener should update the event listener when the target, eventName, or options change",
      "useEventListener should remove the event listener when the component using useEventListener is removed from the DOM",
    ],
    learningHeading: "useEventListener hook",
    note: [
      "created useEventListener hook to add event listener to target element.",
    ],
    image: Challange61,
  },
  {
    id: 62,
    name: "useRandomInterval hook",
    heading: "useRandomInterval hook",
    description:
      "useRandomInterval is useful for executing a specified callback function at random intervals within a specified range.",
    problem: [
      "useRandomInterval should return a function that the user can call to clear the timeout",
      "useRandomInterval should call the callback function at random intervals between minDelay and maxDelay",
      "useRandomInterval should clear the timeout when the component using useRandomInterval is removed from the DOM",
    ],
    learningHeading: "useRandomInterval hook",
    note: [
      "created useRandomInterval hook to trigger a callback at random intervals with helper options.",
    ],
    image: Challange62,
  },
  {
    id: 63,
    name: "useMediaQuery hook",
    heading: "useMediaQuery hook",
    description:
      "useMediaQuery allows you to determine if the document's dimensions match a specific media query string. It also listens for changes in the document's dimensions in order to detect when it matches or stops matching the same media query string.It uses the browser's matchMedia API under the hood.",
    problem: [
      "useMediaQuery should return a boolean representing if the document's dimensions match the media query string that was passed to useMediaQuery",
      "useMediaQuery should re-calculate if the media query string matches the document's dimensions when the document's dimensions change",
      "useMediaQuery should remove any listeners it established when the component using it is removed from the DOM",
    ],
    learningHeading: "useMediaQuery hook",
    note: [
      "created useMediaQuery hook to detect dimensions and listen to changes in dimensions.",
    ],
    image: Challange63,
  },
  {
    id: 64,
    name: "useIntervalWhen hook",
    heading: "useIntervalWhen hook",
    description:
      "useIntervalWhen is useful for creating an interval timer that can be controlled based on a certain condition (when). It allows you to specify a callback function to be executed at a regular interval every ms milliseconds. Additionally, you can choose whether the interval should startImmediately or wait ms milliseconds (as is the default with useInterval).",
    problem: [
      "useIntervalWhen should return a function that clears the interval when invoked",
      "useIntervalWhen should call the callback function every ms milliseconds when when is true",
      "useIntervalWhen should not call the callback function when when is false",
      "useIntervalWhen should call the callback function immediately when startImmediately is true",
      "useIntervalWhen should not call the callback function immediately when startImmediately is false",
      "useIntervalWhen should update the interval when ms changes",
      "useIntervalWhen should clear the interval when the component is removed from the DOM",
    ],
    learningHeading: "useIntervalWhen hook",
    note: [
      "created useIntervalWhen hook to trigger interval timer that can be controlled based on a certain condition. It allows you to specify a callback function to be executed at a regular interval every ms milliseconds. Additionally, you can choose whether the interval should startImmediately or wait ms milliseconds (as is the default with useInterval)",
    ],
    image: Challange64,
  },
  {
    id: 65,
    name: "useMouse hook",
    heading: "useMouse hook",
    description:
      "useMouse gives you a convenient way to both track the mouse position relative to the entire document as well as the mouse position relative to a specific element if you so choose. It uses the mousemove browser event under the hood. No matter what: x: The mouse position relative to the entire document's left edge. y: The mouse position relative to the entire document's top edge. If ref is attached to an element: elementX: The mouse position relative to the element's left edge. elementY: The mouse position relative to the element's top edge. elementPositionX: The element's position relative to the entire document. elementPositionY: The element's position relative to the entire document.",
    problem: [
      "useMouse should return an array with the first item being an object with the keys from the example and the second being a ref the user can attach to an element",
      "useMouse should set up a mousemove event listener on the document",
      "When the mouse moves, if the ref is not attached to an element, useMouse should only update its x and y properties",
      "When the ref is attached to an element, useMouse should update its x, y, elementX, elementY, elementPositionX, and elementPositionY properties",
      "useMouse should remove the mousemove event listener when the component using useMouse is removed from the DOM",
    ],
    learningHeading: "useMouse hook",
    note: [
      "created useMouse hook to both track the mouse position relative to the entire document as well as the mouse position relative to a specific element.",
    ],
    image: Challange65,
  },
  {
    id: 66,
    name: "useClickAway hook",
    heading: "useClickAway hook",
    description:
      "Finish implementing the useClickAway hook so that, as seen in App.js, when the user clicks outside of the modal (the dialog element), the callback function passed to useClickAway is invoked which will then hide the modal.",
    problem: [
      "useClickAway should return a ref that the consumer of useClickAway can attach to an element",
      "Call useClickAway's callback function when clicking outside the ref's element",
      "Don't call useClickAway's callback function when clicking inside the ref's element",
      "Remove any event listeners when the component using useClickAway is removed from the DOM",
    ],
    learningHeading: "useClickAway hook",
    note: [
      "created useClickAway hook so when the user clicks outside of the modal the callback function passed to useClickAway is invoked.",
    ],
    image: Challange66,
  },
  {
    id: 67,
    name: "useNetworkState hook",
    heading: "useNetworkState hook",
    description:
      "useNetworkState is a convenient way to get the current network status of the user's device.It uses the browser's online and offline events as well as navigator.connection's change event under the hood.",
    problem: [
      "useNetworkState should return an object with the following properties: online, downlink, downlinkMax, effectiveType, rtt, saveData, and type",
      "useNetworkState should subscribe to the online and offline events on the window object",
      "useNetworkState should subscribe to the change event on the navigator.connection objet",
      "useNetworkState should return the current network state when the online or offline events are fired",
      "useNetworkState should clean up its event listeners when the component using useNetworkState is removed from the DOM",
    ],
    learningHeading: "useNetworkState hook",
    note: ["created useNetworkState hook to get network status."],
    image: Challange67,
  },
  {
    id: 68,
    name: "useLogger hook",
    heading: "useLogger hook",
    description:
      "useLogger is a hook that can be used in development to give you more insight into when your component renders and re-renders. Specifically, it logs the name you give it along with any arguments as well as if the component is on the initial render (mounted), being updated (updated), or about to be removed from the DOM (unmounted).",
    problem: [
      "useLogger should log name, the event, and any arguments passed to it",
      "useLogger should log mounted on the initial render of the component using useLogger",
      "useLogger should log updated when the component using useLogger is updated",
      "useLogger should log unmounted when the component using useLogger is removed from the DOM",
      "useLogger should support multiple arguments",
    ],
    learningHeading: "useLogger hook",
    note: [
      "created useLogger hook to give you more insight into when your component renders and re-renders.",
    ],
    image: Challange68,
  },
  {
    id: 69,
    name: "useOrientation hook",
    heading: "useOrientation hook",
    description:
      "useOrientation gives you a convenient way to get the current orientation of the user's device.It works by listening for the change event on screen.orientation if the browser supports it, or else it falls back to listen to orientationchange on the window object if it doesn't.",
    problem: [
      "useOrientation should return an object with angle and type properties",
      "useOrientation should listen to change on screen.orientation if the browser supports it",
      "useOrientation should listen to orientationchange on window if the browser doesn't support screen.orientation",
      "useOrientation should update the state with the device's orientation whenever the event handler is invoked",
      "useOrientation should remove the event listeners when the component using useOrientation is removed from the DOM",
    ],
    learningHeading: "useOrientation hook",
    note: [
      "created useObjectState hook to get the current orientation of the user's device.",
    ],
    image: Challange69,
  },
  {
    id: 70,
    name: "useBattery hook",
    heading: "useBattery hook",
    description:
      "The useBattery hook uses the browser's navigator.getBattery API in order to access and monitor the battery status of the user’s device.The battery events you'll want to listen for are: levelchange, chargingchange, chargingtimechange, and dischargingtimechange.",
    problem: [
      "useBattery should return an object with the following properties - supported, loading, level, charging, chargingTime, dischargingTime",
      "useBattery should set supported and loading to false when navigator.getBattery is not supported",
      "useBattery should update its state with the battery information from the user's device",
      "useBattery should update its state with the battery information from the user's device when the battery information changes",
      "useBattery should remove any event listeners it established when the component using useBattery is removed from the DOM",
    ],
    learningHeading: "useBattery hook",
    note: ["created useBattery hook to get battery status."],
    image: Challange70,
  },
  {
    id: 71,
    name: "usePageLeave hook",
    heading: "usePageLeave hook",
    description:
      "usePageLeave is useful for tracking when a user leaves or navigates away from a web page. It works by listening to the document's mouseout event under the hood.",
    problem: [
      "usePageLeave should accept a callback function as its only argument",
      "usePageLeave should add an event listener to the document for the mouseout event",
      "usePageLeave should call the callback function when the user mouses out of the page",
      "usePageLeave should not call the callback if the user mouses out of the page and then back in",
      "usePageLeave should remove the event listener when the component using usePageLeave is removed from the DOM",
    ],
    learningHeading: "usePageLeave hook",
    note: [
      "created usePageLeave hook to tracking when a user leaves or navigates away.",
    ],
    image: Challange71,
  },

  {
    id: 72,
    name: "useLongPress hook",
    heading: "useLongPress hook",
    description:
      "useLongPress gives you a convenient way to add and manage long-press interactions to an element in a React application.",
    problem: [
      "useLongPress should return an object with the following properties: onMouseDown, onMouseUp, onMouseLeave, onTouchStart, and onTouchEnd",
      "useLongPress should call the onStart callback when the user presses down on the element",
      "useLongPress should call the onFinish callback when the user has long pressed the element",
      "useLongPress should call the onCancel callback when the user has not long pressed the element and clear the timer",
      "useLongPress should support touch events",
      "useLongPress should call the callback after the threshold has passed",
      "useLongPress should not call any callbacks if the user presses down on the element but does not long press it",
      "useLongPress should ignore any events that are not mouse or touch events",
    ],
    learningHeading: "useLongPress hook",
    note: ["created useLongPress hook to trigger for a long press."],
    image: Challange72,
  },
  {
    id: 73,
    name: "useKeyPress hook",
    heading: "useKeyPress hook",
    description:
      "useKeyPress gives you a convenient way to listen for key presses on a specific target. It defaults to adding an event listener for the keydown event on window, but allows the user to customize that via its third options argument.",
    problem: [
      "useKeyPress should add an event listener for the keydown event on window",
      "useKeyPress should call the handler function when the key argument matches the event.key value",
      "useKeyPress should support event options via the options argument",
      "useKeyPress should remove the event listener when the component using useKeyPress is removed from the DOM",
    ],
    learningHeading: "useKeyPress hook",
    note: [
      "created useKeyPress hook to listen for key presses on a specific target.",
    ],
    image: Challange73,
  },
  {
    id: 74,
    name: "useThrottle hook",
    heading: "useThrottle hook",
    description:
      "useThrottle gives you control over how often a value is updated. It accepts a value and an optional interval and returns a throttled value that will only be updated at most every interval milliseconds.",
    problem: [
      "useThrottle should return a throttled value",
      "useThrottle should only update the throttled value at most every interval milliseconds",
      "useThrottle should update the throttled value immediately if the value changes after interval milliseconds have passed since the last update",
      "useThrottle should clear the timeout when the component using useThrottle is removed from the DOM",
    ],
    learningHeading: "useThrottle hook",
    note: ["created useThrottle hook to delay the updated value."],
    image: Challange74,
  },
  {
    id: 75,
    name: "useIdle hook",
    heading: "useIdle hook",
    description:
      "useIdle provides a simple way to know if the user has been idle or inactive. It defines 'idle' by going a specified amount of time without any of the following events: mousemove, mousedown, resize, keydown, touchstart, wheel, and visibilitychange.",
    problem: [
      "useIdle should take a ms argument that defaults to 1000 * 20 (20 seconds)",
      "useIdle should return true if the user has been idle for ms milliseconds, otherwise it should return false",
      "useIdle should listen for the following events: mousemove, mousedown, resize, keydown, touchstart, wheel, and visibilitychange",
      "useIdle should reset its internal timer whenever any relevant event occurs",
      "useIdle should clean up all event listeners when the component using useIdle is removed from the DOM",
    ],
    learningHeading: "useIdle hook",
    note: ["created useIdle hook to detect idle state and change status."],
    image: Challange75,
  },
  {
    id: 76,
    name: "useFetch hook",
    heading: "useFetch hook",
    description:
      "useFetch allows you to easily fetch data from a specified url using the browser's fetch API and provides a consistent pattern for handling success (data) and error states. It also incorporates an internal caching mechanism to store and retrieve previously fetched data as well as a mechanism to ignore stale responses if the component unmounts or if a new request is made before the previous one completes.",
    problem: [
      "useFetch should return an object with error and data properties",
      "useFetch should return the data if the request is successful",
      "useFetch should return the error if the request fails",
      "useFetch should cache the response if the same request is made again",
      "useFetch should reset its state if the url changes",
    ],
    learningHeading: "useFetch hook",
    note: [
      "created useFetch hook to easily fetch data from a specified url with internal caching mechanism to store and retrieve previously fetched data.",
    ],
    image: Challange76,
  },
  {
    id: 77,
    name: "useCountdown hook",
    heading: "useCountdown hook",
    description:
      "useCountdown is a convenient way to create and manage a countdown timer. Every interval until endTime, onTick will be invoked. When endTime is reached, onComplete will be invoked and the timer will stop.",
    problem: [
      "useCountdown should count down to endTime, call onTick every interval, call onComplete upon reaching endTime, and return a value that represents how much time is left until endTime",
      "useCountdown should stop counting down and the timer's interval should be cleared when the component using useCountdown is removed from the DOM",
      "useCountdown should return a count which is how many intervals are left until endTime",
    ],
    learningHeading: "useCountdown hook",
    note: ["created useObjectState hook to count click away form tab."],
    image: Challange77,
  },
  {
    id: 78,
    name: "useGeolocation hook",
    heading: "useGeolocation hook",
    description:
      "useGeolocation provides a simple way to get access to the user's geolocation information using the Geolocation API.It gets the user's current location with navigator.geolocation.getCurrentPosition and it watches the user's current location with navigator.geolocation.watchPosition.",
    problem: [
      "useGeolocation should return an object with the following properties: loading, accuracy, altitude, altitudeAccuracy, heading, latitude, longitude, speed, timestamp, and error",
      "useGeolocation should set the loading property to true on the initial render",
      "Using getCurrentPosition, useGeolocation should get the user's current position and update its state accordingly",
      "useGeolocation should update its state when the user's location changes",
      "useGeolocation should set the error property when an error occurs",
      "Using clearWatch, useGeolocation should clear any listeners it's set when the component is removed from the DOM",
    ],
    learningHeading: "useGeolocation hook",
    note: ["created useGeolocation hook to display the geo location."],
    image: Challange78,
  },
  {
    id: 79,
    name: "useLocalStorage hook",
    heading: "useLocalStorage hook",
    description:
      "useLocalStorage gives you a convenient interface for storing and retrieving data from local storage in a React application. Its API is similar to useState, but it stores the value in localState instead of component state.",
    problem: [
      "useLocalStorage should return an array with two items, the local storage value at key and a function to update that value",
      "useLocalStorage should subscribe to storage events and update the value in localStorage at key when the value changes",
      "useLocalStorage should set the value in localStorage at key to initialValue if there's not a value in localStorage at key and initialValue is defined",
      "useLocalStorage should update the value in localStorage at key with the value passed to setState",
      "useLocalStorage should support an updater function similar to useState",
      "useLocalStorage should clean up its storage event listener when the component using useLocalStorage is removed from the DOM",
    ],
    learningHeading: "useLocalStorage hook",
    note: [
      "created useLocalStorage hook to store and retrieve data from local storage.",
    ],
    image: Challange79,
  },
  {
    id: 80,
    name: "useSessionStorage hook",
    heading: "useSessionStorage hook",
    description:
      "useSessionStorage gives you a convenient interface for storing and retrieving data from session storage in a React application. Its API is similar to useState, but it stores the value in sessionStorage instead of component state.",
    problem: [
      "useSessionStorage should return an array with two items, the sessionStorage value at key and a function to update that value",
      "useSessionStorage should subscribe to storage events and update the value in sessionStorage at key when the value changes",
      "useSessionStorage should set the value in sessionStorage at key to initialValue if there's not a value in sessionStorage at key and initialValue is defined",
      "useSessionStorage should update the value in sessionStorage at key with the value passed to setState",
      "useSessionStorage should support an updater function similar to useState",
      "useSessionStorage should clean up its storage event listener when the component using useSessionStorage is removed from the DOM",
    ],
    learningHeading: "useSessionStorage hook",
    note: [
      "created useSessionStorage hook to store and retrieve value in session Storage.",
    ],
    image: Challange80,
  },
];

export default Snippents;
